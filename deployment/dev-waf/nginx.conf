# Developer WAF Nginx Configuration
user nobody;
worker_processes auto;
error_log /usr/local/openresty/waf/logs/error.log info;
pid /var/run/nginx.pid;

events {
    worker_connections 1024;
    use epoll;
}

http {
    include /etc/nginx/mime.types;
    default_type application/octet-stream;
    
    # Lua package path
    lua_package_path "/usr/local/openresty/waf/?.lua;;";
    
    # Initialize WAF
    init_by_lua_block {
        require "waf-engine"
        waf = WAF:new()
        waf:load_policies("/usr/local/openresty/waf/policies")
    }
    
    # Custom log format for WAF events
    log_format waf_format '$remote_addr - $remote_user [$time_local] '
                          '"$request" $status $body_bytes_sent '
                          '"$http_referer" "$http_user_agent"';
    
    access_log /usr/local/openresty/waf/logs/access.log waf_format;
    
    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=global:10m rate=100r/s;
    limit_req_zone $binary_remote_addr zone=strict:10m rate=10r/s;
    
    # Upstream for your development application
    upstream dev_app {
        server host.docker.internal:3000;  # Default dev server
        keepalive 32;
    }
    
    # WAF status and metrics server
    server {
        listen 9090;
        server_name _;
        
        # WAF status endpoint
        location /waf/status {
            content_by_lua_block {
                local cjson = require "cjson"
                local status = {
                    status = "active",
                    version = "1.0.0-dev",
                    policies_loaded = waf:get_policy_count(),
                    rules_active = waf:get_active_rules_count(),
                    requests_processed = ngx.shared.waf_stats:get("requests_processed") or 0,
                    threats_blocked = ngx.shared.waf_stats:get("threats_blocked") or 0,
                    timestamp = ngx.time()
                }
                ngx.say(cjson.encode(status))
            }
        }
        
        # WAF metrics (Prometheus format)
        location /metrics {
            content_by_lua_block {
                local requests_processed = ngx.shared.waf_stats:get("requests_processed") or 0
                local threats_blocked = ngx.shared.waf_stats:get("threats_blocked") or 0
                local policies_loaded = waf:get_policy_count()
                
                ngx.say("# HELP waf_requests_total Total number of requests processed")
                ngx.say("# TYPE waf_requests_total counter")
                ngx.say("waf_requests_total " .. requests_processed)
                ngx.say("")
                ngx.say("# HELP waf_threats_blocked_total Total number of threats blocked")
                ngx.say("# TYPE waf_threats_blocked_total counter")
                ngx.say("waf_threats_blocked_total " .. threats_blocked)
                ngx.say("")
                ngx.say("# HELP waf_policies_loaded Number of security policies loaded")
                ngx.say("# TYPE waf_policies_loaded gauge")
                ngx.say("waf_policies_loaded " .. policies_loaded)
            }
        }
        
        # Request replay endpoint
        location /waf/replay {
            content_by_lua_block {
                ngx.req.read_body()
                local body = ngx.req.get_body_data()
                if not body then
                    ngx.status = 400
                    ngx.say('{"error": "Request body required"}')
                    return
                end
                
                local cjson = require "cjson"
                local replay_request = cjson.decode(body)
                
                -- Execute replay with debugging
                local result = waf:replay_request(replay_request, true)
                ngx.say(cjson.encode(result))
            }
        }
        
        # Policy reload endpoint
        location /waf/reload {
            content_by_lua_block {
                local success = waf:reload_policies("/usr/local/openresty/waf/policies")
                local cjson = require "cjson"
                ngx.say(cjson.encode({
                    success = success,
                    policies_loaded = waf:get_policy_count(),
                    timestamp = ngx.time()
                }))
            }
        }
    }
    
    # Main WAF proxy server
    server {
        listen 80;
        listen [::]:80;
        server_name _;
        
        # Shared memory for WAF statistics  
        lua_shared_dict waf_stats 10m;
        lua_shared_dict waf_cache 10m;
        
        # Initialize WAF variables
        set $waf_action "";
        set $waf_rule_id "";
        set $waf_threat_score "";
        set $waf_processing_time "";
        set $waf_request_id "";
        
        # Global rate limiting
        limit_req zone=global burst=50 nodelay;
        
        # WAF processing for all requests
        access_by_lua_block {
            -- Generate unique request ID
            local request_id = ngx.var.request_id or ngx.time() .. "-" .. math.random(10000, 99999)
            ngx.var.waf_request_id = request_id
            
            -- Prepare request data
            local request_data = {
                id = request_id,
                method = ngx.var.request_method,
                uri = ngx.var.request_uri,
                args = ngx.req.get_uri_args(),
                headers = ngx.req.get_headers(),
                source_ip = ngx.var.remote_addr,
                user_agent = ngx.var.http_user_agent,
                timestamp = ngx.time()
            }
            
            -- Read request body for POST/PUT
            if ngx.var.request_method == "POST" or ngx.var.request_method == "PUT" then
                ngx.req.read_body()
                request_data.body = ngx.req.get_body_data()
            end
            
            -- Process through WAF engine
            local start_time = ngx.now()
            local waf_result = waf:process_request(request_data)
            local processing_time = (ngx.now() - start_time) * 1000
            
            -- Set variables for logging
            ngx.var.waf_action = waf_result.action
            ngx.var.waf_rule_id = table.concat(waf_result.rule_matches or {}, ",")
            ngx.var.waf_threat_score = waf_result.threat_score or 0
            ngx.var.waf_processing_time = string.format("%.2f", processing_time)
            
            -- Update statistics
            local stats = ngx.shared.waf_stats
            stats:incr("requests_processed", 1, 0)
            
            -- Handle WAF decision
            if waf_result.action == "block" then
                stats:incr("threats_blocked", 1, 0)
                ngx.status = waf_result.status_code or 403
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"error": "Request blocked by WAF", "rule_id": "' .. (waf_result.rule_matches[1] or "unknown") .. '", "request_id": "' .. request_id .. '"}')
                ngx.exit(ngx.status)
            elseif waf_result.action == "challenge" then
                ngx.status = 429
                ngx.header["Retry-After"] = "60"
                ngx.header["Content-Type"] = "application/json"
                ngx.say('{"error": "Rate limited", "request_id": "' .. request_id .. '"}')
                ngx.exit(429)
            end
            
            -- Add WAF headers for debugging
            ngx.req.set_header("X-WAF-Request-ID", request_id)
            ngx.req.set_header("X-WAF-Processing-Time", processing_time .. "ms")
            ngx.req.set_header("X-WAF-Threat-Score", waf_result.threat_score or 0)
        }
        
        # Proxy to development application
        location / {
            proxy_pass http://dev_app;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Add WAF debugging headers (only if variables are set)
            proxy_set_header X-WAF-Request-ID $waf_request_id;
        }
    }
}