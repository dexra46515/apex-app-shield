# Nginx WAF Integration Configuration
# This configuration integrates with your Supabase WAF for inline protection

events {
    worker_connections 1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    
    # Logging configuration
    log_format waf_log '$remote_addr - $remote_user [$time_local] '
                       '"$request" $status $body_bytes_sent '
                       '"$http_referer" "$http_user_agent" '
                       'waf_action="$waf_action" waf_reason="$waf_reason" '
                       'processing_time="$waf_processing_time"ms';
    
    access_log /var/log/nginx/waf_access.log waf_log;
    error_log  /var/log/nginx/waf_error.log;

    # Rate limiting zones
    limit_req_zone $binary_remote_addr zone=global:10m rate=10r/s;
    limit_req_zone $binary_remote_addr zone=strict:10m rate=1r/s;

    # Geo blocking (example countries)
    geo $blocked_country {
        default 0;
        # Add blocked country codes here
        # CN 1;  # Block China
        # RU 1;  # Block Russia
    }

    # WAF processing upstream
    upstream waf_processor {
        server localhost:3001;  # Your WAF processing service
        keepalive 32;
    }

    # Main server block
    server {
        listen 80;
        listen [::]:80;
        server_name _;

        # Security headers
        add_header X-Frame-Options DENY;
        add_header X-Content-Type-Options nosniff;
        add_header X-XSS-Protection "1; mode=block";
        add_header Strict-Transport-Security "max-age=31536000";

        # WAF Integration - Process all requests through WAF
        location @waf_check {
            internal;
            
            # Set variables for WAF processing
            set $waf_action "";
            set $waf_reason "";
            set $waf_processing_time "";
            
            # Prepare request data for WAF
            access_by_lua_block {
                local json = require "cjson"
                local http = require "resty.http"
                
                local httpc = http.new()
                httpc:set_timeout(100)  # 100ms timeout for WAF processing
                
                # Prepare WAF request data
                local waf_request = {
                    method = ngx.var.request_method,
                    url = ngx.var.scheme .. "://" .. ngx.var.host .. ngx.var.request_uri,
                    headers = ngx.req.get_headers(),
                    source_ip = ngx.var.remote_addr,
                    timestamp = ngx.time()
                }
                
                # Add request body for POST/PUT requests
                if ngx.var.request_method == "POST" or ngx.var.request_method == "PUT" then
                    ngx.req.read_body()
                    local body = ngx.req.get_body_data()
                    if body then
                        waf_request.body = body
                    end
                end
                
                # Call WAF processor
                local res, err = httpc:request_uri("YOUR_SUPABASE_URL/functions/v1/inline-waf", {
                    method = "POST",
                    body = json.encode(waf_request),
                    headers = {
                        ["Content-Type"] = "application/json",
                        ["Authorization"] = "Bearer YOUR_SUPABASE_ANON_KEY"
                    }
                })
                
                if res and res.status == 200 then
                    local waf_response = json.decode(res.body)
                    
                    ngx.var.waf_action = waf_response.action or "allow"
                    ngx.var.waf_reason = waf_response.reason or ""
                    ngx.var.waf_processing_time = waf_response.processing_time_ms or "0"
                    
                    # Handle WAF decision
                    if waf_response.action == "block" then
                        ngx.status = waf_response.status_code or 403
                        ngx.say(waf_response.body or "Access Denied")
                        ngx.exit(ngx.status)
                    elseif waf_response.action == "challenge" then
                        ngx.status = 429
                        ngx.header["Retry-After"] = "60"
                        ngx.say("Rate limited - please try again later")
                        ngx.exit(429)
                    end
                else
                    # WAF error - fail open (allow traffic)
                    ngx.var.waf_action = "allow"
                    ngx.var.waf_reason = "waf_error"
                    ngx.log(ngx.ERR, "WAF processing error: " .. (err or "unknown"))
                end
            }
        }

        # Apply WAF check to all locations
        location / {
            # Basic security checks first
            if ($blocked_country) {
                return 403 "Access denied from your location";
            }

            # Rate limiting
            limit_req zone=global burst=20 nodelay;
            
            # Process through WAF
            access_by_lua_block {
                # This triggers the WAF check
                ngx.exec("@waf_check")
            }
            
            # Proxy to your application
            proxy_pass http://your_application_backend;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Add WAF headers to backend
            proxy_set_header X-WAF-Action $waf_action;
            proxy_set_header X-WAF-Reason $waf_reason;
            proxy_set_header X-WAF-Processing-Time $waf_processing_time;
        }

        # Health check endpoint
        location /health {
            access_log off;
            return 200 "OK";
        }

        # WAF status endpoint
        location /waf/status {
            access_log off;
            content_by_lua_block {
                local json = require "cjson"
                local status = {
                    status = "active",
                    version = "1.0.0",
                    timestamp = ngx.time()
                }
                ngx.say(json.encode(status))
            }
        }
    }

    # HTTPS server block (recommended for production)
    server {
        listen 443 ssl http2;
        listen [::]:443 ssl http2;
        server_name _;

        # SSL configuration
        ssl_certificate /path/to/certificate.crt;
        ssl_certificate_key /path/to/private.key;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384;
        ssl_prefer_server_ciphers off;

        # Include the same configuration as HTTP server
        include /etc/nginx/conf.d/waf-common.conf;
    }
}