#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const { Command } = require('commander');
const axios = require('axios');
const yaml = require('js-yaml');
const chalk = require('chalk');
const ora = require('ora');
const inquirer = require('inquirer');

const program = new Command();

// Configuration
const CONFIG_FILE = path.join(process.env.HOME || process.env.USERPROFILE, '.ana-waf-config.json');
const DEFAULT_CONFIG = {
  supabase_url: '',
  supabase_anon_key: '',
  waf_endpoint: 'http://localhost:8080',
  waf_management_endpoint: 'http://localhost:9090'
};

class ANAWafCLI {
  constructor() {
    this.config = this.loadConfig();
  }

  loadConfig() {
    try {
      if (fs.existsSync(CONFIG_FILE)) {
        return { ...DEFAULT_CONFIG, ...JSON.parse(fs.readFileSync(CONFIG_FILE, 'utf8')) };
      }
    } catch (error) {
      console.warn(chalk.yellow('Warning: Could not load config file, using defaults'));
    }
    return { ...DEFAULT_CONFIG };
  }

  saveConfig() {
    try {
      fs.writeFileSync(CONFIG_FILE, JSON.stringify(this.config, null, 2));
    } catch (error) {
      console.error(chalk.red('Error saving config:', error.message));
    }
  }

  async configure() {
    console.log(chalk.blue('üîß Configuring ANA WAF CLI'));
    
    const answers = await inquirer.prompt([
      {
        type: 'input',
        name: 'supabase_url',
        message: 'Supabase URL:',
        default: this.config.supabase_url
      },
      {
        type: 'password',
        name: 'supabase_anon_key', 
        message: 'Supabase Anon Key:',
        default: this.config.supabase_anon_key
      },
      {
        type: 'input',
        name: 'waf_endpoint',
        message: 'WAF Endpoint:',
        default: this.config.waf_endpoint
      },
      {
        type: 'input',
        name: 'waf_management_endpoint',
        message: 'WAF Management Endpoint:',
        default: this.config.waf_management_endpoint
      }
    ]);

    this.config = { ...this.config, ...answers };
    this.saveConfig();
    
    console.log(chalk.green('‚úÖ Configuration saved successfully!'));
  }

  async testSecurity(options) {
    const spinner = ora('Running security tests...').start();
    
    try {
      const testConfig = {
        targetUrl: options.url,
        testSuite: options.suite || 'comprehensive',
        customPayloads: options.payloads ? this.loadPayloads(options.payloads) : undefined
      };

      if (options.openapi) {
        testConfig.openApiSpec = this.loadOpenApiSpec(options.openapi);
        testConfig.generateFromSpec = true;
      }

      const response = await axios.post(
        `${this.config.supabase_url}/functions/v1/cicd-security-tester`,
        {
          action: 'run_security_tests',
          config: testConfig
        },
        {
          headers: {
            'Authorization': `Bearer ${this.config.supabase_anon_key}`,
            'Content-Type': 'application/json'
          }
        }
      );

      spinner.succeed('Security tests completed');
      
      const results = response.data;
      this.displayTestResults(results);
      
      // Exit with error code if vulnerabilities found and strict mode
      if (options.strict && results.vulnerabilities_found > 0) {
        console.log(chalk.red('\n‚ùå Exiting with error code due to vulnerabilities found (strict mode)'));
        process.exit(1);
      }
      
      // Exit with error if score below threshold
      if (options.minScore && results.security_score < options.minScore) {
        console.log(chalk.red(`\n‚ùå Security score ${results.security_score} below minimum threshold ${options.minScore}`));
        process.exit(1);
      }

    } catch (error) {
      spinner.fail('Security test failed');
      console.error(chalk.red('Error:', error.response?.data?.error || error.message));
      process.exit(1);
    }
  }

  async simulateTraffic(options) {
    const spinner = ora('Simulating traffic...').start();
    
    try {
      const config = {
        targetUrl: options.url,
        pattern: options.pattern || 'mixed',
        count: options.count || 10
      };

      if (options.openapi) {
        config.openApiSpec = this.loadOpenApiSpec(options.openapi);
        config.generateFromSpec = true;
      }

      const response = await axios.post(
        `${this.config.supabase_url}/functions/v1/simulate-traffic`,
        config,
        {
          headers: {
            'Authorization': `Bearer ${this.config.supabase_anon_key}`,
            'Content-Type': 'application/json'
          }
        }
      );

      spinner.succeed('Traffic simulation completed');
      
      const results = response.data;
      console.log(chalk.blue('\nüìä Traffic Simulation Results:'));
      console.log(`  Total Requests: ${results.summary.total}`);
      console.log(`  Successful: ${chalk.green(results.summary.successful)}`);
      console.log(`  Failed: ${chalk.red(results.summary.failed)}`);
      console.log(`  Attacks: ${chalk.yellow(results.summary.attacks)}`);
      console.log(`  Blocked: ${chalk.red(results.summary.blocked)}`);

      if (options.verbose) {
        console.log('\nüìã Detailed Results:');
        results.results.forEach((result, index) => {
          const statusColor = result.blocked ? chalk.red : (result.success ? chalk.green : chalk.yellow);
          console.log(`  ${index + 1}. ${statusColor(result.status)} ${result.url} (${result.responseTime}ms)`);
          if (result.isAttack) {
            console.log(`     üö® Attack payload: ${result.payload}`);
          }
        });
      }

    } catch (error) {
      spinner.fail('Traffic simulation failed');
      console.error(chalk.red('Error:', error.response?.data?.error || error.message));
      process.exit(1);
    }
  }

  async getWafStatus() {
    const spinner = ora('Getting WAF status...').start();
    
    try {
      const response = await axios.get(`${this.config.waf_management_endpoint}/waf/status`);
      const status = response.data;
      
      spinner.succeed('WAF status retrieved');
      
      console.log(chalk.blue('\nüõ°Ô∏è  WAF Status:'));
      console.log(`  Status: ${status.status === 'active' ? chalk.green('Active') : chalk.red('Inactive')}`);
      console.log(`  Version: ${status.version}`);
      console.log(`  Policies Loaded: ${status.policies_loaded}`);
      console.log(`  Active Rules: ${status.rules_active}`);
      console.log(`  Requests Processed: ${status.requests_processed}`);
      console.log(`  Threats Blocked: ${status.threats_blocked}`);
      console.log(`  Last Updated: ${new Date(status.timestamp * 1000).toLocaleString()}`);

    } catch (error) {
      spinner.fail('Failed to get WAF status');
      console.error(chalk.red('Error:', error.response?.data?.error || error.message));
      if (error.code === 'ECONNREFUSED') {
        console.log(chalk.yellow('\nüí° Tip: Make sure the WAF container is running:'));
        console.log('   docker-compose -f docker-compose.dev.yml up -d');
      }
      process.exit(1);
    }
  }

  async replayRequest(requestId, options) {
    const spinner = ora('Replaying request...').start();
    
    try {
      const response = await axios.post(
        `${this.config.waf_management_endpoint}/waf/replay`,
        {
          request_id: requestId,
          debug_enabled: options.debug || false
        }
      );

      spinner.succeed('Request replayed successfully');
      
      const result = response.data;
      console.log(chalk.blue('\nüîÑ Request Replay Results:'));
      
      if (result.original_request) {
        console.log(chalk.cyan('\nüì• Original Request:'));
        console.log(`  Method: ${result.original_request.method}`);
        console.log(`  URI: ${result.original_request.uri}`);
        console.log(`  Source IP: ${result.original_request.source_ip}`);
        console.log(`  User Agent: ${result.original_request.user_agent}`);
      }

      if (result.original_result) {
        console.log(chalk.cyan('\nüìä Original WAF Result:'));
        console.log(`  Action: ${result.original_result.action}`);
        console.log(`  Threat Score: ${result.original_result.threat_score}`);
        console.log(`  Rules Matched: ${result.original_result.rule_matches?.join(', ') || 'None'}`);
      }

      if (result.replay_result) {
        console.log(chalk.cyan('\nüîÑ Replay Result:'));
        console.log(`  Action: ${result.replay_result.action}`);
        console.log(`  Threat Score: ${result.replay_result.threat_score}`);
        console.log(`  Rules Matched: ${result.replay_result.rule_matches?.join(', ') || 'None'}`);
        
        if (options.debug && result.replay_result.debug_info) {
          console.log(chalk.magenta('\nüêõ Debug Information:'));
          console.log(`  Rules Evaluated: ${result.replay_result.debug_info.rules_evaluated}`);
          console.log(`  Processing Details:`);
          result.replay_result.processing_details?.forEach(detail => {
            console.log(`    - ${detail.rule_id}: ${detail.rule_name} (${detail.action})`);
            if (detail.matched_value) {
              console.log(`      Matched: ${detail.matched_value}`);
            }
          });
        }
      }

    } catch (error) {
      spinner.fail('Request replay failed');
      console.error(chalk.red('Error:', error.response?.data?.error || error.message));
      process.exit(1);
    }
  }

  async reloadPolicies() {
    const spinner = ora('Reloading WAF policies...').start();
    
    try {
      const response = await axios.post(`${this.config.waf_management_endpoint}/waf/reload`);
      const result = response.data;
      
      spinner.succeed('Policies reloaded successfully');
      
      console.log(chalk.green('\n‚úÖ Policy Reload Complete:'));
      console.log(`  Policies Loaded: ${result.policies_loaded}`);
      console.log(`  Timestamp: ${new Date(result.timestamp * 1000).toLocaleString()}`);

    } catch (error) {
      spinner.fail('Failed to reload policies');
      console.error(chalk.red('Error:', error.response?.data?.error || error.message));
      process.exit(1);
    }
  }

  loadPayloads(payloadFile) {
    try {
      const content = fs.readFileSync(payloadFile, 'utf8');
      return payloadFile.endsWith('.json') ? JSON.parse(content) : yaml.load(content);
    } catch (error) {
      console.error(chalk.red('Error loading payload file:', error.message));
      process.exit(1);
    }
  }

  loadOpenApiSpec(specFile) {
    try {
      const content = fs.readFileSync(specFile, 'utf8');
      return specFile.endsWith('.json') ? JSON.parse(content) : yaml.load(content);
    } catch (error) {
      console.error(chalk.red('Error loading OpenAPI spec:', error.message));
      process.exit(1);
    }
  }

  displayTestResults(results) {
    console.log(chalk.blue('\nüîç Security Test Results:'));
    console.log(`  Overall Score: ${this.colorizeScore(results.security_score)}/100`);
    console.log(`  Vulnerabilities Found: ${results.vulnerabilities_found > 0 ? chalk.red(results.vulnerabilities_found) : chalk.green('0')}`);
    console.log(`  Test Duration: ${results.test_duration_ms}ms`);
    
    if (results.test_results) {
      console.log(chalk.cyan('\nüìã Test Categories:'));
      Object.entries(results.test_results).forEach(([category, result]) => {
        const score = this.colorizeScore(result.score);
        console.log(`  ${category.replace(/_/g, ' ').toUpperCase()}: ${score}/100`);
        if (result.vulnerabilities?.length > 0) {
          result.vulnerabilities.forEach(vuln => {
            console.log(`    üö® ${chalk.red(vuln.severity)}: ${vuln.description}`);
          });
        }
      });
    }

    if (results.recommendations?.length > 0) {
      console.log(chalk.yellow('\nüí° Recommendations:'));
      results.recommendations.forEach(rec => {
        console.log(`  ‚Ä¢ ${rec}`);
      });
    }
  }

  colorizeScore(score) {
    if (score >= 80) return chalk.green(score);
    if (score >= 60) return chalk.yellow(score);
    return chalk.red(score);
  }
}

// Initialize CLI
const cli = new ANAWafCLI();

// Configure CLI commands
program
  .name('ana-waf')
  .description('ANA WAF Developer CLI Tool')
  .version('1.0.0');

program
  .command('configure')
  .description('Configure CLI settings')
  .action(() => cli.configure());

program
  .command('test')
  .description('Run security tests against a target URL')
  .requiredOption('-u, --url <url>', 'Target URL to test')
  .option('-s, --suite <suite>', 'Test suite (basic|comprehensive|custom)', 'comprehensive')
  .option('--openapi <file>', 'OpenAPI spec file for guided testing')
  .option('--payloads <file>', 'Custom payload file (JSON/YAML)')
  .option('--strict', 'Exit with error code if vulnerabilities found')
  .option('--min-score <score>', 'Minimum security score required', parseInt)
  .action((options) => cli.testSecurity(options));

program
  .command('simulate')
  .description('Simulate traffic against a target')
  .requiredOption('-u, --url <url>', 'Target URL')
  .option('-p, --pattern <pattern>', 'Traffic pattern (mixed|attack|legitimate)', 'mixed')
  .option('-c, --count <count>', 'Number of requests', parseInt, 10)
  .option('--openapi <file>', 'OpenAPI spec for realistic traffic')
  .option('-v, --verbose', 'Verbose output')
  .action((options) => cli.simulateTraffic(options));

program
  .command('status')
  .description('Get WAF status and metrics')
  .action(() => cli.getWafStatus());

program
  .command('replay')
  .description('Replay a specific request with debugging')
  .argument('<requestId>', 'Request ID to replay')
  .option('-d, --debug', 'Enable debug mode for replay')
  .action((requestId, options) => cli.replayRequest(requestId, options));

program
  .command('reload')
  .description('Reload WAF policies')
  .action(() => cli.reloadPolicies());

// Parse command line arguments
program.parse();